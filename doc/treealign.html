<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>treealign - training tree alignment classifiers and aligning syntactic trees</title>
<link rel="stylesheet" href="/~joerg/css/pod.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:_securityagent@gamma.local" />
</head>

<body>


<!-- INDEX BEGIN -->
<div name="index">
<p><a name="__index__"></a></p>

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
	<ul>

		<li><a href="#options">OPTIONS</a></li>
		<ul>

			<li><a href="#input_options">Input options</a></li>
			<li><a href="#training_options">Training options</a></li>
			<li><a href="#alignment_options">Alignment options</a></li>
			<li><a href="#runtime_and_other_options">Runtime and other options</a></li>
		</ul>

	</ul>

	<li><a href="#see_also">SEE ALSO</a></li>
	<li><a href="#author">AUTHOR</a></li>
	<li><a href="#copyright_and_license">COPYRIGHT AND LICENSE</a></li>
</ul>

<hr name="index" />
</div>
<!-- INDEX END -->

<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>treealign - training tree alignment classifiers and aligning syntactic trees</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<pre>
    treealign [OPTIONS]</pre>
<pre>
    # train a model from tree aligned data
    treealign -n 100 -m treealign.model -a train-data.xml</pre>
<pre>
    # aligning a parallel treebank
    treealign -m treealign.model -a parallel-treebank.xml &gt; aligned.xml</pre>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>This script allows you to train a tree alignment model and to apply them to parallel treebanks. Tree alignment is based on local binary classification and rich feature sets.</p>
<p>Currently, training data has to be in Stockholm Tree Aligner format. The output format is the same format. Here is a short example of this format (taking from the output of the TreeAligner):</p>
<pre>
 &lt;?xml version=&quot;1.0&quot; ?&gt;
 &lt;treealign&gt;
 &lt;head&gt;
  &lt;alignment-metadata&gt;
    &lt;date&gt;Tue May  4 16:23:04 2010&lt;/date&gt;
    &lt;author&gt;Lingua-Align&lt;/author&gt;
  &lt;/alignment-metadata&gt;
 &lt;/head&gt;
  &lt;treebanks&gt;
    &lt;treebank filename=&quot;treebanks/en/smultron_en_sophie.xml&quot; id=&quot;en&quot;/&gt;
    &lt;treebank filename=&quot;treebanks/sv/smultron_sv_sophie.xml&quot; id=&quot;sv&quot;/&gt;
  &lt;/treebanks&gt;
  &lt;alignments&gt;
    &lt;align author=&quot;Lingua-Align&quot; prob=&quot;0.11502659612149206125&quot; type=&quot;fuzzy&quot;&gt;
      &lt;node node_id=&quot;s105_17&quot; type=&quot;t&quot; treebank_id=&quot;en&quot;/&gt;
      &lt;node node_id=&quot;s109_23&quot; type=&quot;t&quot; treebank_id=&quot;sv&quot;/&gt;
    &lt;/align&gt;
    &lt;align author=&quot;Lingua-Align&quot; prob=&quot;0.45281832125339427364&quot; type=&quot;fuzzy&quot;&gt;
      &lt;node node_id=&quot;s105_34&quot; type=&quot;t&quot; treebank_id=&quot;en&quot;/&gt;
      &lt;node node_id=&quot;s109_15&quot; type=&quot;t&quot; treebank_id=&quot;sv&quot;/&gt;
    &lt;/align&gt;
  &lt;/alignments&gt;
 &lt;/treealign&gt;</pre>
<p>
</p>
<h2><a name="options">OPTIONS</a></h2>
<p>There is a number of options that can be specified on the command line.</p>
<p>
</p>
<h3><a name="input_options">Input options</a></h3>
<dl>
<dt><strong><a name="a_parallel_treebank_file" class="item">-a parallel-treebank-file</a></strong></dt>

<dd>
<p>Name of the file that contains the parallel treebank. Default format is Stockholm Tree Aligner format (where the sentence alignment is implicitely given by tree node alignments). To use a different format use the option -A</p>
</dd>
<dt><strong><a name="a_format" class="item">-A format</a></strong></dt>

<dd>
<p>Format of the parallel treebank/corpus. Default is sta (Stockholm Tree Aligner format). Other options are, for example, 'opus' (CES XML format as it is used in the OPUS corpus)</p>
</dd>
<dt><strong><a name="s_source_treebank_file" class="item">-s source-treebank-file</a></strong></dt>

<dd>
<p>Name of the files that contains the source language treebank. This is useful to sepcify a file that is different from the one that is specified in the 'parallel-treebank-file'. For example, sentence alignment files from OPUS usually refer to non-parsed XML files. With -s we can overwrite this and refer to the parsed corpus instead. However, be aware that the same sentences have to be covered in the same order and appropriate IDs of these sentences have to be found when reading through the treebank files.</p>
</dd>
<dt><strong><a name="s_format" class="item">-S format</a></strong></dt>

<dd>
<p>Format of the source language treebank. Default is TigerXML (which is used in the Stockholm Tree Aligner)</p>
</dd>
<dt><strong><a name="t_target_treebank_file" class="item">-t target-treebank-file</a></strong></dt>

<dd>
<p>Name of the target language treebank file (similar to -s but for the target language)</p>
</dd>
<dt><strong><a name="t_format" class="item">-T format</a></strong></dt>

<dd>
<p>Format of the target language treebank (similar to -S)</p>
</dd>
<dt><strong><a name="w" class="item">-w</a></strong></dt>

<dd>
<p>Swap alignment direction when reading through the parallel treebank</p>
</dd>
<dt><strong><a name="i" class="item">-i</a></strong></dt>

<dd>
<p>Try to align index nodes as well (used in AlpinoXML)</p>
</dd>
</dl>
<p>
</p>
<h3><a name="training_options">Training options</a></h3>
<p>Training will be enabled if a positive number of training sentences iss specified with the -n option OR the modelfile does not exist.</p>
<dl>
<dt><strong><a name="n_nr_sent" class="item">-n nr_sent</a></strong></dt>

<dd>
<p>Specify how many sentence (tree) pairs will be used for training a new tree-aligner model.</p>
</dd>
<dt><strong><a name="f_features" class="item">-f features</a></strong></dt>

<dd>
<p>Define features to be used in training. (For alignment, features are taken from the modelfile.feat file!!) 'features' is a string with feature types separated by ':'. There are various features that can be used and combined. For more details look at <a href="/~joerg/Lingua/Align/Trees/Features.html">the Lingua::Align::Trees::Features manpage</a>. The default is 'insideST2:insideTS2:outsideST2:outsideTS2'</p>
</dd>
<dt><strong><a name="m_model_file" class="item">-m model-file</a></strong></dt>

<dd>
<p>Name of the file to store model parameters / read model parameters</p>
</dd>
<dt><strong><a name="c_classifier" class="item">-c classifier</a></strong></dt>

<dd>
<p>Classifier to be used. Default is 'megam'. Another possiblity is 'clue' which refers to a noisy-or like classifier with independent precision-weighted features (requires probabilistic values for each feature and supports only positive features). Other classifiers may be supported in future releases of Lingua::Align.</p>
</dd>
<dt><strong><a name="m_moses_dir" class="item">-M moses-dir</a></strong></dt>

<dd>
<p>Directory with the GIZA++ and Moses word alignment files that will be used for extracting certain features. Default is 'moses' and the treealigner expects to find files with the following names</p>
<pre>
 &lt;moses-dir&gt;/model/lex.0-0.e2f
 &lt;moses-dir&gt;/model/lex.0-0.f2e
 &lt;moses-dir&gt;/giza.src-trg/src-trg.A3.final.gz
 &lt;moses-dir&gt;/giza.trg-src/trg-src.A3.final.gz
 &lt;moses-dir&gt;/model/aligned.intersect</pre>
<p>An alterantive way of specifying the location of word alignment files is to use the options (-d -D -g -G -y), see below.</p>
</dd>
<dt><strong><a name="d_lexe2f" class="item">-d lexe2f</a></strong></dt>

<dd>
<p>Path to the probabilistic source-to-target lexicon created by Moses from the word aligned corpus. Of course, it could be any kind of bilingual dictionary as long as it provides a score for each entry and it uses the same format as the one created by Moses. Default is <code>moses/model/lex.0-0.e2f</code>.</p>
</dd>
<dt><strong><a name="d_lexf2e" class="item">-D lexf2e</a></strong></dt>

<dd>
<p>Similar to -d but for the target-to-source lexicon. Default is <code>moses/model/lex.0-0.f2e</code></p>
</dd>
<dt><strong><a name="g_giza_e2f_a3" class="item">-g giza.e2f.A3</a></strong></dt>

<dd>
<p>Path to the Viterbi word alignment (source-to-target) created by GIZA++ (or other word aligners producing aligments in the same format). Default is <code>moses/giza.trg-src/trg-src.A3.final.gz</code>.</p>
</dd>
<dt><strong><a name="g_giza_f2e_a3" class="item">-G giza.f2e.A3</a></strong></dt>

<dd>
<p>Similar to -g but for the other alignment direction. Default = <code>moses/giza.trg-src/trg-src.A3.final.gz</code></p>
</dd>
<dt><strong><a name="y_symal_file" class="item">-y symal-file</a></strong></dt>

<dd>
<p>Path to the symmetrized word alignment format created by Moses (or other tools). Default = <code>moses/model/aligned.intersect</code></p>
</dd>
<dt><strong><a name="i_id_file" class="item">-I id-file</a></strong></dt>

<dd>
<p>Name of the file that contains pairs of IDs for all sentences that have been word aligned with GIZA++/Moses. This is useful to match sentences when reading word alignment files for feature extraction (sometimes not all sentences are included in both, the parsed collection and the word aligned data!). Note that word aligments and parallel treebanks have still to be stored in the same order but sentences may be skipped if they do not appear in one of them. The format is like follows:</p>
<pre>
 ## source-file-name    target-file-name
 src-id1   trg-id1
 src-id2   trg-id2
 ....</pre>
<p>The delimiter is one TAB character! n:m alignments are possible (IDs separated by spaces) but only 1:1 alignments will be used in the treealigner anyway.</p>
</dd>
<dt><strong><a name="c" class="item">-C</a></strong></dt>

<dd>
<p>Switch on the linked-children feature (depending on the links between children nodes of the current node pair). This flag has to be specified in both, train and align mode!</p>
</dd>
<dt><strong><a name="u" class="item">-U</a></strong></dt>

<dd>
<p>Switch on the linked-subtree-nodes feature (depending on the links between all descendent nodes of the current node pair). This flag has to be specified in both, train and align mode!</p>
</dd>
<dt><strong><a name="p" class="item">-P</a></strong></dt>

<dd>
<p>Switch on the linked-parent feature (depending on the links between parent nodes of the current node pair). This flag has to be specified in both, train and align mode! This flag should NOT be used together with -U or -C!</p>
</dd>
<dt><strong><a name="r_iter" class="item">-R iter</a></strong></dt>

<dd>
<p>Use &lt;iter&gt; number of iterations for adaptive SEARN style learning. This is only useful in connection with (any of) the link depedency features from above (-C -U -P). Instead of learning from the given true link depedency feature extracted from the training data, this option will run the training several times and adjust these features acoording to the predicted link likelihoods from the previously trained classifier. This is currently very slow because it re-runs the feature extraction procedure (which should not be necessary when re-running the classifier). This should be improved later but the effect of SEARN seems to be very little anyway ....</p>
</dd>
<dt><strong><a name="l" class="item">-L</a></strong></dt>

<dd>
<p>Align terminal nodes only (leaf nodes). It is possible to use this flag together with -N which then forces the aligner to align corresponding node types only (terminals with terminals and non-terminals with non-terminals)</p>
</dd>
<dt><strong><a name="n" class="item">-N</a></strong></dt>

<dd>
<p>Align non-terminal nodes only. If specified together with -L: align corresponding nodes as explained above.</p>
</dd>
<dt><strong><a name="1_weight" class="item">-1 weight</a></strong></dt>

<dd>
<p>Training weight for good (sure) alignments
Default = 3</p>
</dd>
<dt><strong><a name="2_weight" class="item">-2 weight</a></strong></dt>

<dd>
<p>Training weight for fuzzy (possible) alignments
Default = 1</p>
</dd>
<dt><strong><a name="3_weight" class="item">-3 weight</a></strong></dt>

<dd>
<p>Training weight for negative examples (non-aligned nodes)
Default = 1</p>
</dd>
<dt><strong><a name="4_weight" class="item">-4 weight</a></strong></dt>

<dd>
<p>Training weight for weak alignments (new category in our Europarl data)
Default = 1</p>
</dd>
<dt><strong><a name="k" class="item">-k</a></strong></dt>

<dd>
<p>Keep the feature file extracted for training which usually is removed to save storage space. The features are stored in __train.$$ (where $$ corresponds to the process ID)</p>
</dd>
</dl>
<p>
</p>
<h3><a name="alignment_options">Alignment options</a></h3>
<dl>
<dt><strong><a name="x_threshold" class="item">-x threshold</a></strong></dt>

<dd>
<p>Score threshold used for tree alignment. Node pairs obtaining scores below this threshold will not be considered in the alignment process.</p>
</dd>
<dt><strong><a name="b_strategy" class="item">-b strategy</a></strong></dt>

<dd>
<p>Type of alignment strategy to be used. Default is 'inference' which refers to a two-step procedure with local classification in the first step and alignment inference in the second (see LinkSearch with argument -l). An alternative strategy is called 'bottom-up' in which the alignment is done in a greedy bottom-up fashion starting with leaf node pairs and going up to the root nodes. Nodes are linked immediately when the classification score (conditional link likelihood) exceeds the threshold (usually 0.5). Aligned nodes are removed from the search space. Therefore, only 1:1 links are returned. In a final step link likelihoods are used to align previously unlinked nodes with the selected alignment inference strategy in the same way as in the two-step procedure.</p>
</dd>
<dt><strong><a name="l_linksearch" class="item">-l LinkSearch</a></strong></dt>

<dd>
<p>Link strategy used to extract the node aligments after classification. Default strategy is 'greedy'. Other possible strategies are 'wellformed' (greedy + wellformedness criteria) and threshold (allow all links above the threshold score). You can also add the option 'final' (by adding the string '_final') to the selected strategy. In that case the aligner will first do the basic link search and then add links between nodes that obey the well-formedness criteria if either source or target language node is not linked yet. In other words, this final step makes 1:many links in the data that do not violate wellformedness. Yet another option is 'and' (which can be added as the string '_and' to the selected strategy, also in combination with '_final'). Using this option unlinked nodes (source and target) will be aligned in a last step in a greedy way even if they violate well-formedness. For example: 'wellformed_final_and' will force the aligner to, first, look for 1:1 links that are well-formed (multiple links are not allowed), then add well-formed links between nodes where one of them is already linked to another one, and, finally, adds links between still unlinked nodes.</p>
</dd>
<dt><strong><a name="u" class="item">-u</a></strong></dt>

<dd>
<p>Switch to add-links mode (union). Existing links between nodes will be kept in the output file and new ones will be added. (In the default mode, existing links will be considered for evaluation only). This option is espcially useful if one wants to use a pipeline of alignments, for example, terminal node alignment first and non-terminal nodes in the next step.</p>
</dd>
<dt><strong><a name="k" class="item">-K</a></strong></dt>

<dd>
<p>Similar to -u: switches to 'add-link' mode but now forces the aligner to use existing links to compete with the new ones. This means that the scores of existing links will be used in the link search algorithm applied for aligning tree nodes. This may also cause some existing links to disappear, for example, because they are not conform to the wellformedness criteria anymore.</p>
</dd>
</dl>
<p>
</p>
<h3><a name="runtime_and_other_options">Runtime and other options</a></h3>
<dl>
<dt><strong><a name="v" class="item">-v</a></strong></dt>

<dd>
<p>Verbose output</p>
</dd>
<dt><strong><a name="o_format" class="item">-O format</a></strong></dt>

<dd>
<p>Output format (one of sta (=default) or dublin (= Dublin subtree aligner format)</p>
</dd>
</dl>
<p>
</p>
<hr />
<h1><a name="see_also">SEE ALSO</a></h1>
<p><a href="/~joerg/Lingua/Align/Trees.html">the Lingua::Align::Trees manpage</a>, <a href="/~joerg/Lingua/Align/Features.html">the Lingua::Align::Features manpage</a>, <a href="/~joerg/Lingua/Align/Corpus.html">the Lingua::Align::Corpus manpage</a></p>
<p>
</p>
<hr />
<h1><a name="author">AUTHOR</a></h1>
<p>Joerg Tiedemann</p>
<p>
</p>
<hr />
<h1><a name="copyright_and_license">COPYRIGHT AND LICENSE</a></h1>
<p>Copyright (C) 2009 by Joerg Tiedemann</p>
<p>This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.8.8 or,
at your option, any later version of Perl 5 you may have available.</p>
<p>Copyright for MegaM by Hal Daume III
see <a href="http://www.cs.utah.edu/~hal/megam/">http://www.cs.utah.edu/~hal/megam/</a> for more information
Paper: Notes on CG and LM-BFGS Optimization of Logistic Regression, 2004
<a href="http://www.cs.utah.edu/~hal/docs/daume04cg-bfgs.pdf">http://www.cs.utah.edu/~hal/docs/daume04cg-bfgs.pdf</a></p>

</body>

</html>
